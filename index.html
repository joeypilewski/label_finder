<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shipping Label Extractor</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <!-- React and ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Lucide React icons as simple SVG components
    const Upload = ({ className, size = 24 }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>
    );

    const Download = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="8 9 12 13 16 9"></polyline>
        <line x1="12" y1="3" x2="12" y2="13"></line>
      </svg>
    );

    const FileText = ({ className, size = 24 }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
        <polyline points="14 2 14 8 20 8"></polyline>
        <line x1="16" y1="13" x2="8" y2="13"></line>
        <line x1="16" y1="17" x2="8" y2="17"></line>
        <polyline points="10 9 9 9 8 9"></polyline>
      </svg>
    );

    const Loader2 = ({ className, size = 24 }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="2" x2="12" y2="6"></line>
        <line x1="12" y1="18" x2="12" y2="22"></line>
        <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
        <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
        <line x1="2" y1="12" x2="6" y2="12"></line>
        <line x1="18" y1="12" x2="22" y2="12"></line>
        <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
        <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
      </svg>
    );

    function ShippingLabelExtractor() {
      const [file, setFile] = useState(null);
      const [labels, setLabels] = useState([]);
      const [processing, setProcessing] = useState(false);
      const [error, setError] = useState('');
      const [pdfLibLoaded, setPdfLibLoaded] = useState(false);

      useEffect(() => {
        // Check if PDF.js is loaded
        if (typeof pdfjsLib !== 'undefined') {
          setPdfLibLoaded(true);
        }
      }, []);

      const handleFileUpload = async (e) => {
        const uploadedFile = e.target.files[0];
        if (!uploadedFile) return;

        setFile(uploadedFile);
        setError('');
        setProcessing(true);
        setLabels([]);

        if (!pdfLibLoaded && uploadedFile.type === 'application/pdf') {
          setError('PDF library is still loading. Please wait a moment and try again.');
          setProcessing(false);
          return;
        }

        try {
          if (uploadedFile.type === 'application/pdf') {
            await processPDF(uploadedFile);
          } else if (uploadedFile.type.startsWith('image/')) {
            await processImage(uploadedFile);
          } else {
            setError('Please upload a PDF or image file');
            setProcessing(false);
          }
        } catch (err) {
          setError('Error processing file: ' + err.message);
          setProcessing(false);
        }
      };

      const detectBorder = (canvas) => {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const width = canvas.width;
        const height = canvas.height;
        
        console.log(`Border detection starting for canvas ${width}x${height}`);
        
        // Detect continuous horizontal and vertical lines (likely borders)
        const horizontalLines = [];
        const verticalLines = [];
        const threshold = 40; // Lower threshold to catch more borders
        const continuityThreshold = 0.5; // 50% of pixels must be part of the line
        
        // Scan for horizontal lines (top and bottom borders)
        for (let y = 0; y < height; y++) {
          let edgePixels = 0;
          let totalChecked = 0;
          
          for (let x = 1; x < width - 1; x++) {
            const idx = (y * width + x) * 4;
            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            // Check pixel above and below
            const above = ((Math.max(0, y - 1)) * width + x) * 4;
            const below = ((Math.min(height - 1, y + 1)) * width + x) * 4;
            
            const grayAbove = (data[above] + data[above + 1] + data[above + 2]) / 3;
            const grayBelow = (data[below] + data[below + 1] + data[below + 2]) / 3;
            
            const diffAbove = Math.abs(gray - grayAbove);
            const diffBelow = Math.abs(gray - grayBelow);
            
            if (diffAbove > threshold || diffBelow > threshold) {
              edgePixels++;
            }
            totalChecked++;
          }
          
          const continuity = edgePixels / totalChecked;
          if (continuity > continuityThreshold) {
            horizontalLines.push({ y, strength: continuity });
          }
        }
        
        // Scan for vertical lines (left and right borders)
        for (let x = 0; x < width; x++) {
          let edgePixels = 0;
          let totalChecked = 0;
          
          for (let y = 1; y < height - 1; y++) {
            const idx = (y * width + x) * 4;
            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            // Check pixel left and right
            const left = (y * width + Math.max(0, x - 1)) * 4;
            const right = (y * width + Math.min(width - 1, x + 1)) * 4;
            
            const grayLeft = (data[left] + data[left + 1] + data[left + 2]) / 3;
            const grayRight = (data[right] + data[right + 1] + data[right + 2]) / 3;
            
            const diffLeft = Math.abs(gray - grayLeft);
            const diffRight = Math.abs(gray - grayRight);
            
            if (diffLeft > threshold || diffRight > threshold) {
              edgePixels++;
            }
            totalChecked++;
          }
          
          const continuity = edgePixels / totalChecked;
          if (continuity > continuityThreshold) {
            verticalLines.push({ x, strength: continuity });
          }
        }
        
        console.log(`Found ${horizontalLines.length} horizontal lines, ${verticalLines.length} vertical lines`);
        
        // Find the outermost borders (first from top, last from bottom, etc.)
        const margin = Math.floor(Math.min(width, height) * 0.01); // 1% margin from edges
        const maxSearchDepth = Math.floor(Math.min(width, height) * 0.4); // Search within 40% from edges
        
        let top = null, bottom = null, left = null, right = null;
        
        // Find top border (first strong line from top)
        for (const line of horizontalLines) {
          if (line.y > margin && line.y < maxSearchDepth) {
            top = line.y;
            console.log(`Top border found at y=${top}`);
            break;
          }
        }
        
        // Find bottom border (first strong line from bottom)
        for (let i = horizontalLines.length - 1; i >= 0; i--) {
          const line = horizontalLines[i];
          if (line.y < height - margin && line.y > height - maxSearchDepth) {
            bottom = line.y;
            console.log(`Bottom border found at y=${bottom}`);
            break;
          }
        }
        
        // Find left border (first strong line from left)
        for (const line of verticalLines) {
          if (line.x > margin && line.x < maxSearchDepth) {
            left = line.x;
            console.log(`Left border found at x=${left}`);
            break;
          }
        }
        
        // Find right border (first strong line from right)
        for (let i = verticalLines.length - 1; i >= 0; i--) {
          const line = verticalLines[i];
          if (line.x < width - margin && line.x > width - maxSearchDepth) {
            right = line.x;
            console.log(`Right border found at x=${right}`);
            break;
          }
        }
        
        // Validate that we found a reasonable border
        if (top !== null && bottom !== null && left !== null && right !== null) {
          const foundWidth = right - left;
          const foundHeight = bottom - top;
          const minSize = Math.min(width, height) * 0.3; // At least 30% of canvas
          
          console.log(`Border box: ${foundWidth}x${foundHeight} (${(foundWidth/width*100).toFixed(1)}% x ${(foundHeight/height*100).toFixed(1)}%)`);
          
          // Make sure the detected region is substantial and smaller than the full canvas
          if (foundWidth > minSize && foundHeight > minSize && 
              foundWidth < width * 0.99 && foundHeight < height * 0.99) {
            console.log('✓ Border detected and validated');
            return { left, top, right, bottom, detected: true };
          } else {
            console.log('✗ Border validation failed');
          }
        } else {
          console.log(`✗ Not all borders found: top=${top}, bottom=${bottom}, left=${left}, right=${right}`);
        }
        
        return null;
      };

      const processPDF = async (file) => {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const numPages = pdf.numPages;
        const extractedLabels = [];

        for (let i = 1; i <= numPages; i++) {
          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: 1 });
          
          // Get page dimensions in points (1 point = 1/72 inch)
          const widthInches = viewport.width / 72;
          const heightInches = viewport.height / 72;
          
          console.log(`Page ${i}: ${widthInches.toFixed(2)}" x ${heightInches.toFixed(2)}"`);
          
          // Determine page type
          const is4x6 = (
            (Math.abs(widthInches - 4) < 0.5 && Math.abs(heightInches - 6) < 0.5) ||
            (Math.abs(widthInches - 6) < 0.5 && Math.abs(heightInches - 4) < 0.5)
          );
          
          const is85x11 = (
            (Math.abs(widthInches - 8.5) < 0.5 && Math.abs(heightInches - 11) < 0.5) ||
            (Math.abs(widthInches - 11) < 0.5 && Math.abs(heightInches - 8.5) < 0.5)
          );
          
          if (is4x6) {
            // Already 4x6, just output as-is
            const label = await render4x6Page(page, viewport, i, 1);
            extractedLabels.push(label);
          } else if (is85x11) {
            // 8.5x11 page - need to split into two 4x6 labels
            const labels = await split85x11Page(page, viewport, i);
            extractedLabels.push(...labels);
          } else {
            // Unknown size - try to detect label region
            const label = await detectAndExtractLabel(page, viewport, i);
            if (label) extractedLabels.push(label);
          }
        }

        setLabels(extractedLabels);
        setProcessing(false);
      };

      const split85x11Page = async (page, viewport, pageNum) => {
        const widthInches = viewport.width / 72;
        const heightInches = viewport.height / 72;
        
        // Check if page is portrait (8.5x11) or landscape (11x8.5)
        const isPortrait = heightInches > widthInches;
        
        // Render at high resolution
        const scale = 3;
        const renderViewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = renderViewport.width;
        canvas.height = renderViewport.height;
        
        await page.render({
          canvasContext: context,
          viewport: renderViewport
        }).promise;
        
        const labels = [];
        
        if (isPortrait) {
          // Portrait: Split horizontally into TOP and BOTTOM halves
          const halfHeight = canvas.height / 2;
          
          for (let half = 0; half < 2; half++) {
            const halfSourceY = half * halfHeight;
            
            const halfCanvas = document.createElement('canvas');
            const halfContext = halfCanvas.getContext('2d');
            halfCanvas.width = canvas.width;
            halfCanvas.height = halfHeight;
            
            halfContext.drawImage(
              canvas,
              0, halfSourceY, canvas.width, halfHeight,
              0, 0, canvas.width, halfHeight
            );
            
            // ROTATE: Create a rotated version (90 degrees clockwise)
            const rotatedCanvas = document.createElement('canvas');
            const rotatedContext = rotatedCanvas.getContext('2d');
            rotatedCanvas.width = halfCanvas.height;
            rotatedCanvas.height = halfCanvas.width;
            
            rotatedContext.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
            rotatedContext.rotate(Math.PI / 2);
            rotatedContext.drawImage(halfCanvas, -halfCanvas.width / 2, -halfCanvas.height / 2);
            
            // Detect border on rotated canvas
            const border = detectBorder(rotatedCanvas);
            
            const outputCanvas = document.createElement('canvas');
            const outputContext = outputCanvas.getContext('2d');
            outputCanvas.width = 1200;
            outputCanvas.height = 1800;
            
            outputContext.fillStyle = 'white';
            outputContext.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            let sourceCanvas, sourceX, sourceY, sourceWidth, sourceHeight;
            
            if (border) {
              sourceCanvas = rotatedCanvas;
              sourceX = border.left;
              sourceY = border.top;
              sourceWidth = border.right - border.left;
              sourceHeight = border.bottom - border.top;
            } else {
              sourceCanvas = rotatedCanvas;
              sourceX = 0;
              sourceY = 0;
              sourceWidth = rotatedCanvas.width;
              sourceHeight = rotatedCanvas.height;
            }
            
            const scale2 = Math.min(
              outputCanvas.width / sourceWidth,
              outputCanvas.height / sourceHeight
            );
            
            const scaledWidth = sourceWidth * scale2;
            const scaledHeight = sourceHeight * scale2;
            const xOffset = (outputCanvas.width - scaledWidth) / 2;
            const yOffset = (outputCanvas.height - scaledHeight) / 2;
            
            outputContext.drawImage(
              sourceCanvas,
              sourceX, sourceY, sourceWidth, sourceHeight,
              xOffset, yOffset, scaledWidth, scaledHeight
            );
            
            labels.push({
              id: `${pageNum}-${half + 1}`,
              data: outputCanvas.toDataURL('image/png'),
              name: `label_page${pageNum}_${half === 0 ? 'top' : 'bottom'}.png`,
              orientation: 'portrait',
              source: `8.5x11 portrait (${half === 0 ? 'top' : 'bottom'}, rotated${border ? ', border detected' : ''})`
            });
          }
        } else {
          // Landscape: Split vertically into LEFT and RIGHT halves
          const halfWidth = canvas.width / 2;
          
          for (let half = 0; half < 2; half++) {
            const halfSourceX = half * halfWidth;
            
            const halfCanvas = document.createElement('canvas');
            const halfContext = halfCanvas.getContext('2d');
            halfCanvas.width = halfWidth;
            halfCanvas.height = canvas.height;
            
            halfContext.drawImage(
              canvas,
              halfSourceX, 0, halfWidth, canvas.height,
              0, 0, halfWidth, canvas.height
            );
            
            // Detect border on half canvas
            const border = detectBorder(halfCanvas);
            
            const outputCanvas = document.createElement('canvas');
            const outputContext = outputCanvas.getContext('2d');
            outputCanvas.width = 1200;
            outputCanvas.height = 1800;
            
            outputContext.fillStyle = 'white';
            outputContext.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            let croppedSourceX, croppedSourceY, croppedSourceWidth, croppedSourceHeight;
            
            if (border) {
              croppedSourceX = border.left;
              croppedSourceY = border.top;
              croppedSourceWidth = border.right - border.left;
              croppedSourceHeight = border.bottom - border.top;
            } else {
              croppedSourceX = 0;
              croppedSourceY = 0;
              croppedSourceWidth = halfCanvas.width;
              croppedSourceHeight = halfCanvas.height;
            }
            
            const scale2 = Math.min(
              outputCanvas.width / croppedSourceWidth,
              outputCanvas.height / croppedSourceHeight
            );
            
            const scaledWidth = croppedSourceWidth * scale2;
            const scaledHeight = croppedSourceHeight * scale2;
            const xOffset = (outputCanvas.width - scaledWidth) / 2;
            const yOffset = (outputCanvas.height - scaledHeight) / 2;
            
            outputContext.drawImage(
              halfCanvas,
              croppedSourceX, croppedSourceY, croppedSourceWidth, croppedSourceHeight,
              xOffset, yOffset, scaledWidth, scaledHeight
            );
            
            labels.push({
              id: `${pageNum}-${half + 1}`,
              data: outputCanvas.toDataURL('image/png'),
              name: `label_page${pageNum}_${half === 0 ? 'left' : 'right'}.png`,
              orientation: 'portrait',
              source: `11x8.5 landscape (${half === 0 ? 'left' : 'right'}${border ? ', border detected' : ''})`
            });
          }
        }
        
        return labels;
      };

      const render4x6Page = async (page, viewport, pageNum, labelNum) => {
        const scale = 3;
        const scaledViewport = page.getViewport({ scale });
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;
        
        await page.render({
          canvasContext: context,
          viewport: scaledViewport
        }).promise;
        
        // Detect border on the 4x6 page
        const border = detectBorder(canvas);
        
        const outputCanvas = document.createElement('canvas');
        const outputContext = outputCanvas.getContext('2d');
        outputCanvas.width = 1200;
        outputCanvas.height = 1800;
        
        outputContext.fillStyle = 'white';
        outputContext.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
        
        let sourceX, sourceY, sourceWidth, sourceHeight;
        
        if (border) {
          sourceX = border.left;
          sourceY = border.top;
          sourceWidth = border.right - border.left;
          sourceHeight = border.bottom - border.top;
        } else {
          sourceX = 0;
          sourceY = 0;
          sourceWidth = canvas.width;
          sourceHeight = canvas.height;
        }
        
        const scale2 = Math.min(
          outputCanvas.width / sourceWidth,
          outputCanvas.height / sourceHeight
        );
        
        const scaledWidth = sourceWidth * scale2;
        const scaledHeight = sourceHeight * scale2;
        const xOffset = (outputCanvas.width - scaledWidth) / 2;
        const yOffset = (outputCanvas.height - scaledHeight) / 2;
        
        outputContext.drawImage(
          canvas,
          sourceX, sourceY, sourceWidth, sourceHeight,
          xOffset, yOffset, scaledWidth, scaledHeight
        );
        
        return {
          id: `${pageNum}-${labelNum}`,
          data: outputCanvas.toDataURL('image/png'),
          name: `label_page${pageNum}_${labelNum}.png`,
          orientation: 'portrait',
          source: `4x6 page${border ? ' (border detected)' : ''}`
        };
      };

      const detectAndExtractLabel = async (page, viewport, pageNum) => {
        const scale = 3;
        const scaledViewport = page.getViewport({ scale });
        
        const tempCanvas = document.createElement('canvas');
        const tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = scaledViewport.width;
        tempCanvas.height = scaledViewport.height;
        
        await page.render({
          canvasContext: tempContext,
          viewport: scaledViewport
        }).promise;

        // Detect border
        const border = detectBorder(tempCanvas);

        const outputCanvas = document.createElement('canvas');
        const outputContext = outputCanvas.getContext('2d');
        outputCanvas.width = 1200;
        outputCanvas.height = 1800;
        
        outputContext.fillStyle = 'white';
        outputContext.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
        
        let sourceX, sourceY, sourceWidth, sourceHeight;
        
        if (border) {
          sourceX = border.left;
          sourceY = border.top;
          sourceWidth = border.right - border.left;
          sourceHeight = border.bottom - border.top;
        } else {
          sourceX = 0;
          sourceY = 0;
          sourceWidth = tempCanvas.width;
          sourceHeight = tempCanvas.height;
        }
        
        const scale2 = Math.min(
          outputCanvas.width / sourceWidth,
          outputCanvas.height / sourceHeight
        );
        
        const scaledWidth = sourceWidth * scale2;
        const scaledHeight = sourceHeight * scale2;
        const xOffset = (outputCanvas.width - scaledWidth) / 2;
        const yOffset = (outputCanvas.height - scaledHeight) / 2;
        
        outputContext.drawImage(
          tempCanvas,
          sourceX, sourceY, sourceWidth, sourceHeight,
          xOffset, yOffset, scaledWidth, scaledHeight
        );

        return {
          id: `${pageNum}-1`,
          data: outputCanvas.toDataURL('image/png'),
          name: `label_page${pageNum}.png`,
          orientation: 'portrait',
          source: `unknown size page${border ? ' (border detected)' : ''}`
        };
      };

      const processImage = async (file) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          
          reader.onload = (e) => {
            const img = new Image();
            
            img.onload = () => {
              try {
                const tempCanvas = document.createElement('canvas');
                const tempContext = tempCanvas.getContext('2d');
                
                const scale = Math.max(2000 / Math.max(img.width, img.height), 1);
                tempCanvas.width = img.width * scale;
                tempCanvas.height = img.height * scale;
                
                tempContext.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Detect border
                const border = detectBorder(tempCanvas);
                
                const isLandscape = img.width > img.height;
                
                const outputCanvas = document.createElement('canvas');
                const outputContext = outputCanvas.getContext('2d');
                
                if (isLandscape) {
                  outputCanvas.width = 1800;
                  outputCanvas.height = 1200;
                } else {
                  outputCanvas.width = 1200;
                  outputCanvas.height = 1800;
                }
                
                outputContext.fillStyle = 'white';
                outputContext.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                
                let sourceX, sourceY, sourceWidth, sourceHeight;
                
                if (border) {
                  sourceX = border.left;
                  sourceY = border.top;
                  sourceWidth = border.right - border.left;
                  sourceHeight = border.bottom - border.top;
                } else {
                  sourceX = 0;
                  sourceY = 0;
                  sourceWidth = tempCanvas.width;
                  sourceHeight = tempCanvas.height;
                }
                
                const outputScale = Math.min(
                  outputCanvas.width / sourceWidth,
                  outputCanvas.height / sourceHeight
                );
                
                const scaledWidth = sourceWidth * outputScale;
                const scaledHeight = sourceHeight * outputScale;
                
                const xOffset = (outputCanvas.width - scaledWidth) / 2;
                const yOffset = (outputCanvas.height - scaledHeight) / 2;
                
                outputContext.drawImage(
                  tempCanvas,
                  sourceX, sourceY, sourceWidth, sourceHeight,
                  xOffset, yOffset, scaledWidth, scaledHeight
                );
                
                const imageData = outputCanvas.toDataURL('image/png');
                setLabels([{
                  id: 1,
                  data: imageData,
                  name: 'shipping_label.png',
                  orientation: isLandscape ? 'landscape' : 'portrait',
                  source: `image upload${border ? ' (border detected)' : ''}`
                }]);
                setProcessing(false);
                resolve();
              } catch (err) {
                reject(err);
              }
            };
            
            img.onerror = () => reject(new Error('Failed to load image'));
            img.src = e.target.result;
          };
          
          reader.onerror = () => reject(new Error('Failed to read file'));
          reader.readAsDataURL(file);
        });
      };

      const downloadLabel = (label) => {
        const link = document.createElement('a');
        link.href = label.data;
        link.download = label.name;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
          document.body.removeChild(link);
        }, 100);
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
          <div className="max-w-6xl mx-auto">
            <div className="bg-white rounded-xl shadow-xl p-8">
              <h1 className="text-3xl font-bold text-gray-800 mb-2 flex items-center gap-3">
                <FileText className="text-indigo-600" size={36} />
                Shipping Label Extractor
              </h1>
              <p className="text-gray-600 mb-8">
                Upload a PDF file containing shipping labels and extract them as 4x6 downloadable images
              </p>

              <div className="mb-8">
                {!pdfLibLoaded && (
                  <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg flex items-center gap-2 text-blue-700 text-sm">
                    <Loader2 className="animate-spin" size={16} />
                    Loading PDF processor...
                  </div>
                )}
                <label className={`flex flex-col items-center justify-center w-full h-48 border-2 border-dashed rounded-lg transition-colors ${
                  pdfLibLoaded 
                    ? 'border-indigo-300 bg-indigo-50 hover:bg-indigo-100 cursor-pointer' 
                    : 'border-gray-300 bg-gray-50 cursor-not-allowed opacity-60'
                }`}>
                  <div className="flex flex-col items-center justify-center pt-5 pb-6">
                    <Upload className={`w-12 h-12 mb-3 ${pdfLibLoaded ? 'text-indigo-500' : 'text-gray-400'}`} />
                    <p className="mb-2 text-sm text-gray-700">
                      <span className="font-semibold">{pdfLibLoaded ? 'Click to upload' : 'Loading...'}</span> {pdfLibLoaded && 'or drag and drop'}
                    </p>
                    <p className="text-xs text-gray-500">PDF or image files (JPG, PNG, etc.)</p>
                  </div>
                  <input
                    type="file"
                    className="hidden"
                    accept=".pdf,.jpg,.jpeg,.png,.gif,.webp,.bmp"
                    onChange={handleFileUpload}
                    disabled={!pdfLibLoaded}
                  />
                </label>
                {file && (
                  <p className="mt-2 text-sm text-gray-600">
                    Selected: {file.name}
                  </p>
                )}
              </div>

              {error && (
                <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
                  {error}
                </div>
              )}

              {processing && (
                <div className="flex items-center justify-center gap-3 p-8 bg-indigo-50 rounded-lg">
                  <Loader2 className="animate-spin text-indigo-600" size={24} />
                  <span className="text-indigo-700 font-medium">Processing labels...</span>
                </div>
              )}

              {labels.length > 0 && (
                <div>
                  <div className="mb-6">
                    <h2 className="text-xl font-semibold text-gray-800">
                      Extracted Labels ({labels.length})
                    </h2>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {labels.map((label) => (
                      <div
                        key={label.id}
                        className="border border-gray-200 rounded-lg p-4 bg-gray-50 hover:shadow-lg transition-shadow"
                      >
                        <div className="bg-white rounded-md overflow-hidden mb-3 border border-gray-200">
                          <img
                            src={label.data}
                            alt={`Label ${label.id}`}
                            className="w-full h-auto"
                          />
                        </div>
                        <div className="flex items-center justify-between">
                          <div className="flex flex-col gap-1">
                            <div className="flex items-center gap-2">
                              <span className="text-sm font-medium text-gray-700">
                                Label {label.id}
                              </span>
                              {label.orientation && (
                                <span className="text-xs px-2 py-1 bg-indigo-100 text-indigo-700 rounded-full">
                                  {label.orientation}
                                </span>
                              )}
                            </div>
                            {label.source && (
                              <span className="text-xs text-gray-500">
                                {label.source}
                              </span>
                            )}
                          </div>
                          <button
                            onClick={() => downloadLabel(label)}
                            className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors text-sm font-medium"
                          >
                            <Download size={16} />
                            Download
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {labels.length === 0 && !processing && (
                <div className="mt-8 p-6 bg-gray-50 rounded-lg border border-gray-200">
                  <h3 className="font-semibold text-gray-800 mb-3">How to use:</h3>
                  <ol className="list-decimal list-inside space-y-2 text-gray-600 text-sm">
                    <li>Upload a PDF file containing shipping labels</li>
                    <li><strong>4x6 pages:</strong> Outputs as-is (already correct size)</li>
                    <li><strong>8.5x11 portrait:</strong> Splits horizontally into TOP and BOTTOM 4x6 labels</li>
                    <li><strong>11x8.5 landscape:</strong> Splits vertically into LEFT and RIGHT 4x6 labels</li>
                    <li><strong>Border Detection:</strong> Automatically finds label borders and fits to 4x6</li>
                    <li>Download clean, print-ready 4x6 labels as high-quality PNG images</li>
                  </ol>
                  <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                    <strong>Smart Border Detection:</strong> The app detects rectangular borders around labels using edge detection, ensuring only the actual label content is extracted!
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<ShippingLabelExtractor />, document.getElementById('root'));
  </script>
</body>
</html>

